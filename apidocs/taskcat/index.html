<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>taskcat API documentation</title>
<meta name="description" content="taskcat python module" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>taskcat</code></h1>
</header>
<section id="section-intro">
<p>taskcat python module</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
taskcat python module
&#34;&#34;&#34;
from ._cfn.stack import Stack  # noqa: F401
from ._cfn.template import Template  # noqa: F401
from ._cli import main  # noqa: F401
from ._config import Config  # noqa: F401

__all__ = [&#34;Stack&#34;, &#34;Template&#34;, &#34;Config&#34;, &#34;main&#34;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="taskcat.exceptions" href="exceptions.html">taskcat.exceptions</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="taskcat.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>cli_core_class=taskcat._cli_core.CliCore, exit_func=&lt;function exit_with_code&gt;)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(cli_core_class=CliCore, exit_func=exit_with_code):
    signal.signal(signal.SIGINT, _sigint_handler)
    log_level = _setup_logging(sys.argv)
    args = sys.argv[1:]
    if not args:
        args.append(&#34;-h&#34;)
    try:
        _welcome()
        version = get_installed_version()
        cli = cli_core_class(NAME, _cli_modules, DESCRIPTION, version, GLOBAL_ARGS)
        cli.parse(args)
        cli.run()
    except TaskCatException as e:
        LOG.error(str(e), exc_info=_print_tracebacks(log_level))
        exit_func(1)
    except Exception as e:  # pylint: disable=broad-except
        LOG.error(
            &#34;%s %s&#34;, e.__class__.__name__, str(e), exc_info=_print_tracebacks(log_level)
        )
        exit_func(1)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="taskcat.Config"><code class="flex name class">
<span>class <span class="ident">Config</span></span>
<span>(</span><span>sources, uid)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Config:
    def __init__(self, sources: list, uid: uuid.UUID):
        self.config = BaseConfig.from_dict(DEFAULTS)
        self.config.set_source(&#34;TASKCAT_DEFAULT&#34;)
        self.uid = uid
        for source in sources:
            config_dict: dict = source[&#34;config&#34;]
            source_name: str = source[&#34;source&#34;]
            source_config = BaseConfig.from_dict(config_dict)
            source_config.set_source(source_name)
            self.config = BaseConfig.merge(self.config, source_config)

    @classmethod
    # pylint: disable=too-many-locals
    def create(
        cls,
        template_file: Optional[Path] = None,
        args: Optional[dict] = None,
        global_config_path: Path = GENERAL,
        project_config_path: Path = PROJECT,
        overrides_path: Path = OVERRIDES,
        env_vars: Optional[dict] = None,
        project_root: Path = PROJECT_ROOT,
        uid: uuid.UUID = None,
    ) -&gt; &#34;Config&#34;:
        uid = uid if uid else uuid.uuid4()
        project_source = cls._get_project_source(
            cls, project_config_path, project_root, template_file
        )

        # general
        sources = [
            {
                &#34;source&#34;: str(global_config_path),
                &#34;config&#34;: cls._dict_from_file(global_config_path),
            }
        ]

        # project config file
        if project_source:
            sources.append(project_source)

        # template file
        if isinstance(template_file, Path):
            sources.append(
                {
                    &#34;source&#34;: str(template_file),
                    &#34;config&#34;: cls._dict_from_template(template_file),
                }
            )

        # override file
        legacy_override = Path(&#34;./ci/taskcat_project_override.json&#34;).resolve()
        if legacy_override.is_file():
            with open(str(legacy_override), &#34;r&#34;) as file_handle:
                override_params = yaml.safe_load(file_handle)
            LOG.warning(
                f&#34;overrides file {str(legacy_override)} is in legacy &#34;
                f&#34;format, support for this format will be deprecated &#34;
                f&#34;in a future version.&#34;
            )
            override_params = {
                i[&#34;ParameterKey&#34;]: i[&#34;ParameterValue&#34;] for i in override_params
            }
            if not overrides_path.exists():
                LOG.warning(
                    f&#34;Converting overrides to new format and saving in &#34;
                    f&#34;{overrides_path}&#34;
                )
                with open(str(overrides_path), &#34;w&#34;) as file_handle:
                    file_handle.write(yaml.dump(override_params))
            else:
                LOG.warning(
                    f&#34;Ignoring legacy overrides as a current format override &#34;
                    f&#34;file has been found in {str(overrides_path)}&#34;
                )
        if overrides_path.is_file():
            overrides = BaseConfig().to_dict()
            with open(str(overrides_path), &#34;r&#34;) as file_handle:
                override_params = yaml.safe_load(file_handle)
            overrides[&#34;project&#34;][&#34;parameters&#34;] = override_params
            sources.append({&#34;source&#34;: str(overrides_path), &#34;config&#34;: overrides})

        # environment variables
        sources.append(
            {
                &#34;source&#34;: &#34;EnvoronmentVariable&#34;,
                &#34;config&#34;: cls._dict_from_env_vars(env_vars),
            }
        )

        # cli arguments
        if args:
            sources.append({&#34;source&#34;: &#34;CliArgument&#34;, &#34;config&#34;: args})
        return cls(sources=sources, uid=uid)

    # pylint: disable=protected-access
    @staticmethod
    def _get_project_source(base_cls, project_config_path, project_root, template_file):
        try:
            return {
                &#34;source&#34;: str(project_config_path),
                &#34;config&#34;: base_cls._dict_from_file(project_config_path, fail_ok=False),
            }
        except Exception as e:  # pylint: disable=broad-except
            error = e
            try:
                legacy_conf = parse_legacy_config(project_root)
                return {
                    &#34;source&#34;: str(project_root / &#34;ci/taskcat.yml&#34;),
                    &#34;config&#34;: legacy_conf.to_dict(),
                }
            except Exception as e:  # pylint: disable=broad-except
                LOG.debug(str(e), exc_info=True)
                if not template_file:
                    raise error

    @staticmethod
    def _dict_from_file(file_path: Path, fail_ok=True) -&gt; dict:
        config_dict = BaseConfig().to_dict()
        if not file_path.is_file() and fail_ok:
            return config_dict
        try:
            with open(str(file_path), &#34;r&#34;) as file_handle:
                config_dict = yaml.safe_load(file_handle)
            return config_dict
        except Exception as e:  # pylint: disable=broad-except
            LOG.warning(f&#34;failed to load config from {file_path}&#34;)
            LOG.debug(str(e), exc_info=True)
            if not fail_ok:
                raise e
        return config_dict

    @staticmethod
    def _dict_from_template(file_path: Path) -&gt; dict:
        relative_path = str(file_path.relative_to(PROJECT_ROOT))
        config_dict = (
            BaseConfig()
            .from_dict(
                {&#34;project&#34;: {&#34;template&#34;: relative_path}, &#34;tests&#34;: {&#34;default&#34;: {}}}
            )
            .to_dict()
        )
        if not file_path.is_file():
            raise TaskCatException(f&#34;invalid template path {file_path}&#34;)
        try:
            template = Template(str(file_path)).template
        except Exception as e:
            LOG.warning(f&#34;failed to load template from {file_path}&#34;)
            LOG.debug(str(e), exc_info=True)
            raise e
        if not template.get(&#34;Metadata&#34;):
            return config_dict
        if not template[&#34;Metadata&#34;].get(&#34;taskcat&#34;):
            return config_dict
        template_config_dict = template[&#34;Metadata&#34;][&#34;taskcat&#34;]
        if not template_config_dict.get(&#34;project&#34;):
            template_config_dict[&#34;project&#34;] = {}
        template_config_dict[&#34;project&#34;][&#34;template&#34;] = relative_path
        if not template_config_dict.get(&#34;tests&#34;):
            template_config_dict[&#34;tests&#34;] = {&#34;default&#34;: {}}
        return template_config_dict

    # pylint: disable=protected-access
    @staticmethod
    def _dict_from_env_vars(
        env_vars: Optional[Union[os._Environ, Dict[str, str]]] = None
    ):
        if env_vars is None:
            env_vars = os.environ
        config_dict: Dict[str, Dict[str, Union[str, bool, int]]] = {}
        for key, value in env_vars.items():
            if key.startswith(&#34;TASKCAT_&#34;):
                key = key[8:].lower()
                sub_key = None
                key_section = None
                for section in [&#34;general&#34;, &#34;project&#34;, &#34;tests&#34;]:
                    if key.startswith(section):
                        sub_key = key[len(section) + 1 :]
                        key_section = section
                if isinstance(sub_key, str) and isinstance(key_section, str):
                    if value.isnumeric():
                        value = int(value)
                    elif value.lower() in [&#34;true&#34;, &#34;false&#34;]:
                        value = value.lower() == &#34;true&#34;
                    if not config_dict.get(key_section):
                        config_dict[key_section] = {}
                    config_dict[key_section][sub_key] = value
        return config_dict

    def get_regions(self, boto3_cache: Boto3Cache = None):
        if boto3_cache is None:
            boto3_cache = Boto3Cache()

        region_objects: Dict[str, Dict[str, RegionObj]] = {}
        for test_name, test in self.config.tests.items():
            region_objects[test_name] = {}
            for region in test.regions:
                profile = test.auth.get(region, &#34;default&#34;) if test.auth else &#34;default&#34;
                region_objects[test_name][region] = RegionObj(
                    name=region,
                    account_id=boto3_cache.account_id(profile),
                    partition=boto3_cache.partition(profile),
                    profile=profile,
                    _boto3_cache=boto3_cache,
                    taskcat_id=self.uid,
                )
        return region_objects

    def get_buckets(self, boto3_cache: Boto3Cache = None):
        regions = self.get_regions(boto3_cache)
        bucket_objects: Dict[str, S3BucketObj] = {}
        bucket_mappings: Dict[str, Dict[str, S3BucketObj]] = {}
        for test_name, test in self.config.tests.items():
            bucket_mappings[test_name] = {}
            for region_name, region in regions[test_name].items():
                bucket_obj = self._create_bucket_obj(bucket_objects, region, test)
                bucket_objects[region.account_id] = bucket_obj
                bucket_mappings[test_name][region_name] = bucket_obj
        return bucket_mappings

    def _create_bucket_obj(self, bucket_objects, region, test):
        new = False
        object_acl = (
            self.config.project.s3_object_acl
            if self.config.project.s3_object_acl
            else &#34;private&#34;
        )
        sigv4 = not self.config.project.s3_enable_sig_v2
        if not test.s3_bucket and not bucket_objects.get(region.account_id):
            name = generate_bucket_name(self.config.project.name)
            auto_generated = True
            new = True
        elif bucket_objects.get(region.account_id):
            name = bucket_objects[region.account_id].name
            auto_generated = bucket_objects[region.account_id].auto_generated
        else:
            name = test.s3_bucket
            auto_generated = False
        bucket_region = self._get_bucket_region_for_partition(region.partition)
        bucket_obj = S3BucketObj(
            name=name,
            region=bucket_region,
            account_id=region.account_id,
            s3_client=region.session.client(&#34;s3&#34;, region_name=bucket_region),
            auto_generated=auto_generated,
            object_acl=object_acl,
            sigv4=sigv4,
            taskcat_id=self.uid,
            partition=region.partition,
        )
        if new:
            bucket_obj.create()
        return bucket_obj

    @staticmethod
    def _get_bucket_region_for_partition(partition):
        region = &#34;us-east-1&#34;
        if partition == &#34;aws-us-gov&#34;:
            region = &#34;us-gov-east-1&#34;
        elif partition == &#34;aws-cn&#34;:
            region = &#34;cn-north-1&#34;
        return region

    def get_rendered_parameters(self, bucket_objects, region_objects, template_objects):
        parameters = {}
        template_params = self.get_params_from_templates(template_objects)
        for test_name, test in self.config.tests.items():
            parameters[test_name] = {}
            for region_name in test.regions:
                region_params = template_params[test_name].copy()
                for param_key, param_value in test.parameters.items():
                    if param_key in region_params:
                        region_params[param_key] = param_value
                region = region_objects[test_name][region_name]
                s3bucket = bucket_objects[test_name][region_name]
                parameters[test_name][region_name] = ParamGen(
                    region_params, s3bucket.name, region.name, region.client
                ).results
        return parameters

    @staticmethod
    def get_params_from_templates(template_objects):
        parameters = {}
        for test_name, template in template_objects.items():
            parameters[test_name] = template.parameters()
        return parameters

    def get_templates(self, project_root: Path):
        templates = {}
        for test_name, test in self.config.tests.items():
            templates[test_name] = Template(
                template_path=project_root / test.template,
                project_root=project_root,
                s3_key_prefix=f&#34;{self.config.project.name}/&#34;,
            )
        return templates

    def get_tests(self, project_root, templates, regions, buckets, parameters):
        tests = {}
        for test_name, test in self.config.tests.items():
            region_list = []
            for region_obj in regions[test_name].values():
                region_list.append(
                    TestRegion.from_region_obj(
                        region_obj,
                        buckets[test_name][region_obj.name],
                        parameters[test_name][region_obj.name],
                    )
                )
            tests[test_name] = TestObj(
                name=test_name,
                template_path=project_root / test.template,
                template=templates[test_name],
                project_root=project_root,
                regions=region_list,
            )
        return tests</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="taskcat.Config.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>template_file=None, args=None, global_config_path=PosixPath('/Users/tonynv/.taskcat.yml'), project_config_path=PosixPath('/Users/tonynv/PycharmProjects/taskcat/aws-quickstart.github.io/.taskcat.yml'), overrides_path=PosixPath('/Users/tonynv/PycharmProjects/taskcat/aws-quickstart.github.io/.taskcat_overrides.yml'), env_vars=None, project_root=PosixPath('/Users/tonynv/PycharmProjects/taskcat/aws-quickstart.github.io'), uid=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
# pylint: disable=too-many-locals
def create(
    cls,
    template_file: Optional[Path] = None,
    args: Optional[dict] = None,
    global_config_path: Path = GENERAL,
    project_config_path: Path = PROJECT,
    overrides_path: Path = OVERRIDES,
    env_vars: Optional[dict] = None,
    project_root: Path = PROJECT_ROOT,
    uid: uuid.UUID = None,
) -&gt; &#34;Config&#34;:
    uid = uid if uid else uuid.uuid4()
    project_source = cls._get_project_source(
        cls, project_config_path, project_root, template_file
    )

    # general
    sources = [
        {
            &#34;source&#34;: str(global_config_path),
            &#34;config&#34;: cls._dict_from_file(global_config_path),
        }
    ]

    # project config file
    if project_source:
        sources.append(project_source)

    # template file
    if isinstance(template_file, Path):
        sources.append(
            {
                &#34;source&#34;: str(template_file),
                &#34;config&#34;: cls._dict_from_template(template_file),
            }
        )

    # override file
    legacy_override = Path(&#34;./ci/taskcat_project_override.json&#34;).resolve()
    if legacy_override.is_file():
        with open(str(legacy_override), &#34;r&#34;) as file_handle:
            override_params = yaml.safe_load(file_handle)
        LOG.warning(
            f&#34;overrides file {str(legacy_override)} is in legacy &#34;
            f&#34;format, support for this format will be deprecated &#34;
            f&#34;in a future version.&#34;
        )
        override_params = {
            i[&#34;ParameterKey&#34;]: i[&#34;ParameterValue&#34;] for i in override_params
        }
        if not overrides_path.exists():
            LOG.warning(
                f&#34;Converting overrides to new format and saving in &#34;
                f&#34;{overrides_path}&#34;
            )
            with open(str(overrides_path), &#34;w&#34;) as file_handle:
                file_handle.write(yaml.dump(override_params))
        else:
            LOG.warning(
                f&#34;Ignoring legacy overrides as a current format override &#34;
                f&#34;file has been found in {str(overrides_path)}&#34;
            )
    if overrides_path.is_file():
        overrides = BaseConfig().to_dict()
        with open(str(overrides_path), &#34;r&#34;) as file_handle:
            override_params = yaml.safe_load(file_handle)
        overrides[&#34;project&#34;][&#34;parameters&#34;] = override_params
        sources.append({&#34;source&#34;: str(overrides_path), &#34;config&#34;: overrides})

    # environment variables
    sources.append(
        {
            &#34;source&#34;: &#34;EnvoronmentVariable&#34;,
            &#34;config&#34;: cls._dict_from_env_vars(env_vars),
        }
    )

    # cli arguments
    if args:
        sources.append({&#34;source&#34;: &#34;CliArgument&#34;, &#34;config&#34;: args})
    return cls(sources=sources, uid=uid)</code></pre>
</details>
</dd>
<dt id="taskcat.Config.get_params_from_templates"><code class="name flex">
<span>def <span class="ident">get_params_from_templates</span></span>(<span>template_objects)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_params_from_templates(template_objects):
    parameters = {}
    for test_name, template in template_objects.items():
        parameters[test_name] = template.parameters()
    return parameters</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="taskcat.Config.get_buckets"><code class="name flex">
<span>def <span class="ident">get_buckets</span></span>(<span>self, boto3_cache=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_buckets(self, boto3_cache: Boto3Cache = None):
    regions = self.get_regions(boto3_cache)
    bucket_objects: Dict[str, S3BucketObj] = {}
    bucket_mappings: Dict[str, Dict[str, S3BucketObj]] = {}
    for test_name, test in self.config.tests.items():
        bucket_mappings[test_name] = {}
        for region_name, region in regions[test_name].items():
            bucket_obj = self._create_bucket_obj(bucket_objects, region, test)
            bucket_objects[region.account_id] = bucket_obj
            bucket_mappings[test_name][region_name] = bucket_obj
    return bucket_mappings</code></pre>
</details>
</dd>
<dt id="taskcat.Config.get_regions"><code class="name flex">
<span>def <span class="ident">get_regions</span></span>(<span>self, boto3_cache=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_regions(self, boto3_cache: Boto3Cache = None):
    if boto3_cache is None:
        boto3_cache = Boto3Cache()

    region_objects: Dict[str, Dict[str, RegionObj]] = {}
    for test_name, test in self.config.tests.items():
        region_objects[test_name] = {}
        for region in test.regions:
            profile = test.auth.get(region, &#34;default&#34;) if test.auth else &#34;default&#34;
            region_objects[test_name][region] = RegionObj(
                name=region,
                account_id=boto3_cache.account_id(profile),
                partition=boto3_cache.partition(profile),
                profile=profile,
                _boto3_cache=boto3_cache,
                taskcat_id=self.uid,
            )
    return region_objects</code></pre>
</details>
</dd>
<dt id="taskcat.Config.get_rendered_parameters"><code class="name flex">
<span>def <span class="ident">get_rendered_parameters</span></span>(<span>self, bucket_objects, region_objects, template_objects)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rendered_parameters(self, bucket_objects, region_objects, template_objects):
    parameters = {}
    template_params = self.get_params_from_templates(template_objects)
    for test_name, test in self.config.tests.items():
        parameters[test_name] = {}
        for region_name in test.regions:
            region_params = template_params[test_name].copy()
            for param_key, param_value in test.parameters.items():
                if param_key in region_params:
                    region_params[param_key] = param_value
            region = region_objects[test_name][region_name]
            s3bucket = bucket_objects[test_name][region_name]
            parameters[test_name][region_name] = ParamGen(
                region_params, s3bucket.name, region.name, region.client
            ).results
    return parameters</code></pre>
</details>
</dd>
<dt id="taskcat.Config.get_templates"><code class="name flex">
<span>def <span class="ident">get_templates</span></span>(<span>self, project_root)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_templates(self, project_root: Path):
    templates = {}
    for test_name, test in self.config.tests.items():
        templates[test_name] = Template(
            template_path=project_root / test.template,
            project_root=project_root,
            s3_key_prefix=f&#34;{self.config.project.name}/&#34;,
        )
    return templates</code></pre>
</details>
</dd>
<dt id="taskcat.Config.get_tests"><code class="name flex">
<span>def <span class="ident">get_tests</span></span>(<span>self, project_root, templates, regions, buckets, parameters)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tests(self, project_root, templates, regions, buckets, parameters):
    tests = {}
    for test_name, test in self.config.tests.items():
        region_list = []
        for region_obj in regions[test_name].values():
            region_list.append(
                TestRegion.from_region_obj(
                    region_obj,
                    buckets[test_name][region_obj.name],
                    parameters[test_name][region_obj.name],
                )
            )
        tests[test_name] = TestObj(
            name=test_name,
            template_path=project_root / test.template,
            template=templates[test_name],
            project_root=project_root,
            regions=region_list,
        )
    return tests</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="taskcat.Stack"><code class="flex name class">
<span>class <span class="ident">Stack</span></span>
<span>(</span><span>region, stack_id, template, test_name, uuid=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stack:  # pylint: disable=too-many-instance-attributes

    REMOTE_TEMPLATE_PATH = Path(&#34;.taskcat/.remote_templates&#34;)

    def __init__(
        self,
        region: TestRegion,
        stack_id: str,
        template: Template,
        test_name,
        uuid: UUID = None,
    ):
        uuid = uuid if uuid else uuid4()
        self.test_name: str = test_name
        self.uuid: UUID = uuid
        self.id: str = stack_id
        self.template: Template = template
        self.name: str = self._get_name()
        self.region: TestRegion = region
        self.region_name = region.name
        self.client: boto3.client = region.client(&#34;cloudformation&#34;)
        self.completion_time: timedelta = timedelta(0)

        # properties from additional cfn api calls
        self._events: Events = Events()
        self._resources: Resources = Resources()
        self._children: Stacks = Stacks()
        # properties from describe_stacks response
        self.change_set_id: str = &#34;&#34;
        self.parameters: List[Parameter] = []
        self.creation_time: datetime = datetime.fromtimestamp(0)
        self.deletion_time: datetime = datetime.fromtimestamp(0)
        self.status: str = &#34;&#34;
        self.status_reason: str = &#34;&#34;
        self.disable_rollback: bool = False
        self.timeout_in_minutes: int = 0
        self.capabilities: List[str] = []
        self.outputs: List[Output] = []
        self.tags: List[Tag] = []
        self.parent_id: str = &#34;&#34;
        self.root_id: str = &#34;&#34;
        self._auto_refresh_interval: timedelta = timedelta(seconds=60)
        self._last_event_refresh: datetime = datetime.fromtimestamp(0)
        self._last_resource_refresh: datetime = datetime.fromtimestamp(0)
        self._last_child_refresh: datetime = datetime.fromtimestamp(0)
        self._timer = Timer(self._auto_refresh_interval.total_seconds(), self.refresh)
        self._timer.start()

    def __str__(self):
        return self.id

    def __repr__(self):
        return &#34;&lt;Stack object {} at {}&gt;&#34;.format(self.name, hex(id(self)))

    def _get_region(self) -&gt; str:
        return self.id.split(&#34;:&#34;)[3]

    def _get_name(self) -&gt; str:
        return self.id.split(&#34;:&#34;)[5].split(&#34;/&#34;)[1]

    def _auto_refresh(self, last_refresh):
        if datetime.now() - last_refresh &gt; self._auto_refresh_interval:
            return True
        return False

    @classmethod
    def create(
        cls,
        region: TestRegion,
        stack_name: str,
        template: Template,
        tags: List[Tag] = None,
        disable_rollback: bool = True,
        test_name: str = &#34;&#34;,
        uuid: UUID = None,
    ) -&gt; &#34;Stack&#34;:
        parameters = cls._cfn_format_parameters(region.parameters)
        uuid = uuid if uuid else uuid4()
        cfn_client = region.client(&#34;cloudformation&#34;)
        tags = [t.dump() for t in tags] if tags else []
        bucket_name: str = region.s3_bucket.name
        template.url = s3_url_maker(bucket_name, template.s3_key, region.client(&#34;s3&#34;))
        stack_id = cfn_client.create_stack(
            StackName=stack_name,
            TemplateURL=template.url,
            Parameters=parameters,
            DisableRollback=disable_rollback,
            Tags=tags,
            Capabilities=Capabilities.ALL,
        )[&#34;StackId&#34;]
        stack = cls(region, stack_id, template, test_name, uuid)
        # fetch property values from cfn
        stack.refresh()
        return stack

    @staticmethod
    def _cfn_format_parameters(parameters):
        return [{&#34;ParameterKey&#34;: k, &#34;ParameterValue&#34;: v} for k, v in parameters.items()]

    @classmethod
    def _import_child(
        cls, stack_properties: dict, parent_stack: &#34;Stack&#34;
    ) -&gt; Optional[&#34;Stack&#34;]:
        url = &#34;&#34;
        for event in parent_stack.events():
            if event.physical_id == stack_properties[&#34;StackId&#34;] and event.properties:
                url = event.properties[&#34;TemplateURL&#34;]
        if url.startswith(parent_stack.template.url_prefix()):
            # Template is part of the project, discovering path
            relative_path = url.replace(parent_stack.template.url_prefix(), &#34;&#34;).lstrip(
                &#34;/&#34;
            )
            absolute_path = parent_stack.template.project_root / relative_path
        else:
            # Assuming template is remote to project and downloading it
            cfn_client = parent_stack.client
            tempate_body = cfn_client.get_template(
                StackName=stack_properties[&#34;StackId&#34;]
            )[&#34;TemplateBody&#34;]
            path = parent_stack.template.project_root / Stack.REMOTE_TEMPLATE_PATH
            os.makedirs(path, exist_ok=True)
            fname = (
                &#34;&#34;.join(
                    random.choice(string.ascii_lowercase) for _ in range(16)  # nosec
                )
                + &#34;.template&#34;
            )
            absolute_path = path / fname
            if not absolute_path.exists():
                with open(absolute_path, &#34;w&#34;) as fh:
                    fh.write(tempate_body)
        template = Template(
            template_path=str(absolute_path),
            project_root=parent_stack.template.project_root,
            url=url,
        )
        stack = cls(
            parent_stack.region,
            stack_properties[&#34;StackId&#34;],
            template,
            parent_stack.name,
            parent_stack.uuid,
        )
        stack.set_stack_properties(stack_properties)
        return stack

    @classmethod
    def import_existing(
        cls,
        stack_properties: dict,
        template: Template,
        region: TestRegion,
        test_name: str,
        uid: UUID,
    ) -&gt; &#34;Stack&#34;:
        stack = cls(region, stack_properties[&#34;StackId&#34;], template, test_name, uid)
        stack.set_stack_properties(stack_properties)
        return stack

    def refresh(
        self,
        properties: bool = True,
        events: bool = False,
        resources: bool = False,
        children: bool = False,
    ) -&gt; None:
        if properties:
            self.set_stack_properties()
        if events:
            self._fetch_stack_events()
            self._last_event_refresh = datetime.now()
        if resources:
            self._fetch_stack_resources()
            self._last_resource_refresh = datetime.now()
        if children:
            self._fetch_children()
            self._last_child_refresh = datetime.now()

    def set_stack_properties(self, stack_properties: Optional[dict] = None) -&gt; None:
        # TODO: get time to complete for complete stacks and % complete
        props: dict = stack_properties if stack_properties else {}
        self._timer.cancel()
        if not props:
            describe_stacks = self.client.describe_stacks
            props = describe_stacks(StackName=self.id)[&#34;Stacks&#34;][0]
        iterable_props: List[Tuple[str, Callable]] = [
            (&#34;Parameters&#34;, Parameter),
            (&#34;Outputs&#34;, Output),
            (&#34;Tags&#34;, Tag),
        ]
        for prop_name, prop_class in iterable_props:
            for item in props.get(prop_name, []):
                item = prop_class(item)
                self._merge_props(getattr(self, prop_name.lower()), item)
        for key, value in props.items():
            if key in [p[0] for p in iterable_props]:  # noqa: C412
                continue
            key = pascal_to_snake(key).replace(&#34;stack_&#34;, &#34;&#34;)
            setattr(self, key, value)
        if self.status in StackStatus.IN_PROGRESS:
            self._timer = Timer(
                self._auto_refresh_interval.total_seconds(), self.refresh
            )
            self._timer.start()

    @staticmethod
    def _merge_props(existing_props, new):
        added = False
        for existing_id, prop in enumerate(existing_props):
            if prop.key == new.key:
                existing_props[existing_id] = new
                added = True
        if not added:
            existing_props.append(new)

    def events(self, refresh: bool = False, include_generic: bool = True) -&gt; Events:
        if refresh or not self._events or self._auto_refresh(self._last_event_refresh):
            self._fetch_stack_events()
        events = self._events
        if not include_generic:
            events = Events([event for event in events if not self._is_generic(event)])
        return events

    @staticmethod
    def _is_generic(event: Event) -&gt; bool:
        generic = False
        for regex in GENERIC_ERROR_PATTERNS:
            if re.search(regex, event.status_reason):
                generic = True
        return generic

    def _fetch_stack_events(self) -&gt; None:
        self._last_event_refresh = datetime.now()
        events = Events()
        for page in self.client.get_paginator(&#34;describe_stack_events&#34;).paginate(
            StackName=self.id
        ):
            for event in page[&#34;StackEvents&#34;]:
                events.append(Event(event))
        self._events = events

    def resources(self, refresh: bool = False) -&gt; Resources:
        if (
            refresh
            or not self._resources
            or self._auto_refresh(self._last_resource_refresh)
        ):
            self._fetch_stack_resources()
        return self._resources

    def _fetch_stack_resources(self) -&gt; None:
        self._last_resource_refresh = datetime.now()
        resources = Resources()
        for page in self.client.get_paginator(&#34;list_stack_resources&#34;).paginate(
            StackName=self.id
        ):
            for resource in page[&#34;StackResourceSummaries&#34;]:
                resources.append(Resource(self.id, resource, self.test_name, self.uuid))
        self._resources = resources

    @staticmethod
    def delete(client, stack_id) -&gt; None:
        client.delete_stack(StackName=stack_id)
        LOG.info(f&#34;Deleting stack: {stack_id}&#34;)

    def update(self, *args, **kwargs):
        raise NotImplementedError(&#34;Stack updates not implemented&#34;)

    def _fetch_children(self) -&gt; None:
        self._last_child_refresh = datetime.now()
        for page in self.client.get_paginator(&#34;describe_stacks&#34;).paginate():
            for stack in page[&#34;Stacks&#34;]:
                if self._children.filter(id=stack[&#34;StackId&#34;]):
                    continue
                if &#34;ParentId&#34; in stack.keys():
                    if self.id == stack[&#34;ParentId&#34;]:
                        stack_obj = Stack._import_child(stack, self)
                        self._children.append(stack_obj)

    def children(self, refresh=False) -&gt; Stacks:
        if (
            refresh
            or not self._children
            or self._auto_refresh(self._last_child_refresh)
        ):
            self._fetch_children()
        return self._children

    def descendants(self, refresh=False) -&gt; Stacks:
        if refresh or not self._children:
            self._fetch_children()

        def recurse(stack: Stack, descendants: Stacks = None) -&gt; Stacks:
            descendants = descendants if descendants else Stacks()
            if stack.children(refresh=refresh):
                descendants += stack.children()
                for child in stack.children():
                    descendants = recurse(child, descendants)
            return descendants

        return recurse(self)

    def error_events(
        self, recurse: bool = True, include_generic: bool = False, refresh=False
    ) -&gt; Events:
        errors = Events()
        stacks = Stacks([self])
        if recurse:
            stacks += self.descendants()
        for stack in stacks:
            for status in StackStatus.FAILED:
                errors += stack.events(
                    refresh=refresh, include_generic=include_generic
                ).filter({&#34;status&#34;: status})
        return errors</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="taskcat.Stack.REMOTE_TEMPLATE_PATH"><code class="name">var <span class="ident">REMOTE_TEMPLATE_PATH</span></code></dt>
<dd>
<section class="desc"><p>Path subclass for non-Windows systems.</p>
<p>On a POSIX system, instantiating a Path should return this object.</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="taskcat.Stack.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>region, stack_name, template, tags=None, disable_rollback=True, test_name='', uuid=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create(
    cls,
    region: TestRegion,
    stack_name: str,
    template: Template,
    tags: List[Tag] = None,
    disable_rollback: bool = True,
    test_name: str = &#34;&#34;,
    uuid: UUID = None,
) -&gt; &#34;Stack&#34;:
    parameters = cls._cfn_format_parameters(region.parameters)
    uuid = uuid if uuid else uuid4()
    cfn_client = region.client(&#34;cloudformation&#34;)
    tags = [t.dump() for t in tags] if tags else []
    bucket_name: str = region.s3_bucket.name
    template.url = s3_url_maker(bucket_name, template.s3_key, region.client(&#34;s3&#34;))
    stack_id = cfn_client.create_stack(
        StackName=stack_name,
        TemplateURL=template.url,
        Parameters=parameters,
        DisableRollback=disable_rollback,
        Tags=tags,
        Capabilities=Capabilities.ALL,
    )[&#34;StackId&#34;]
    stack = cls(region, stack_id, template, test_name, uuid)
    # fetch property values from cfn
    stack.refresh()
    return stack</code></pre>
</details>
</dd>
<dt id="taskcat.Stack.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>client, stack_id)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def delete(client, stack_id) -&gt; None:
    client.delete_stack(StackName=stack_id)
    LOG.info(f&#34;Deleting stack: {stack_id}&#34;)</code></pre>
</details>
</dd>
<dt id="taskcat.Stack.import_existing"><code class="name flex">
<span>def <span class="ident">import_existing</span></span>(<span>stack_properties, template, region, test_name, uid)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def import_existing(
    cls,
    stack_properties: dict,
    template: Template,
    region: TestRegion,
    test_name: str,
    uid: UUID,
) -&gt; &#34;Stack&#34;:
    stack = cls(region, stack_properties[&#34;StackId&#34;], template, test_name, uid)
    stack.set_stack_properties(stack_properties)
    return stack</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="taskcat.Stack.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self, refresh=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self, refresh=False) -&gt; Stacks:
    if (
        refresh
        or not self._children
        or self._auto_refresh(self._last_child_refresh)
    ):
        self._fetch_children()
    return self._children</code></pre>
</details>
</dd>
<dt id="taskcat.Stack.descendants"><code class="name flex">
<span>def <span class="ident">descendants</span></span>(<span>self, refresh=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def descendants(self, refresh=False) -&gt; Stacks:
    if refresh or not self._children:
        self._fetch_children()

    def recurse(stack: Stack, descendants: Stacks = None) -&gt; Stacks:
        descendants = descendants if descendants else Stacks()
        if stack.children(refresh=refresh):
            descendants += stack.children()
            for child in stack.children():
                descendants = recurse(child, descendants)
        return descendants

    return recurse(self)</code></pre>
</details>
</dd>
<dt id="taskcat.Stack.error_events"><code class="name flex">
<span>def <span class="ident">error_events</span></span>(<span>self, recurse=True, include_generic=False, refresh=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_events(
    self, recurse: bool = True, include_generic: bool = False, refresh=False
) -&gt; Events:
    errors = Events()
    stacks = Stacks([self])
    if recurse:
        stacks += self.descendants()
    for stack in stacks:
        for status in StackStatus.FAILED:
            errors += stack.events(
                refresh=refresh, include_generic=include_generic
            ).filter({&#34;status&#34;: status})
    return errors</code></pre>
</details>
</dd>
<dt id="taskcat.Stack.events"><code class="name flex">
<span>def <span class="ident">events</span></span>(<span>self, refresh=False, include_generic=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def events(self, refresh: bool = False, include_generic: bool = True) -&gt; Events:
    if refresh or not self._events or self._auto_refresh(self._last_event_refresh):
        self._fetch_stack_events()
    events = self._events
    if not include_generic:
        events = Events([event for event in events if not self._is_generic(event)])
    return events</code></pre>
</details>
</dd>
<dt id="taskcat.Stack.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self, properties=True, events=False, resources=False, children=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(
    self,
    properties: bool = True,
    events: bool = False,
    resources: bool = False,
    children: bool = False,
) -&gt; None:
    if properties:
        self.set_stack_properties()
    if events:
        self._fetch_stack_events()
        self._last_event_refresh = datetime.now()
    if resources:
        self._fetch_stack_resources()
        self._last_resource_refresh = datetime.now()
    if children:
        self._fetch_children()
        self._last_child_refresh = datetime.now()</code></pre>
</details>
</dd>
<dt id="taskcat.Stack.resources"><code class="name flex">
<span>def <span class="ident">resources</span></span>(<span>self, refresh=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resources(self, refresh: bool = False) -&gt; Resources:
    if (
        refresh
        or not self._resources
        or self._auto_refresh(self._last_resource_refresh)
    ):
        self._fetch_stack_resources()
    return self._resources</code></pre>
</details>
</dd>
<dt id="taskcat.Stack.set_stack_properties"><code class="name flex">
<span>def <span class="ident">set_stack_properties</span></span>(<span>self, stack_properties=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_stack_properties(self, stack_properties: Optional[dict] = None) -&gt; None:
    # TODO: get time to complete for complete stacks and % complete
    props: dict = stack_properties if stack_properties else {}
    self._timer.cancel()
    if not props:
        describe_stacks = self.client.describe_stacks
        props = describe_stacks(StackName=self.id)[&#34;Stacks&#34;][0]
    iterable_props: List[Tuple[str, Callable]] = [
        (&#34;Parameters&#34;, Parameter),
        (&#34;Outputs&#34;, Output),
        (&#34;Tags&#34;, Tag),
    ]
    for prop_name, prop_class in iterable_props:
        for item in props.get(prop_name, []):
            item = prop_class(item)
            self._merge_props(getattr(self, prop_name.lower()), item)
    for key, value in props.items():
        if key in [p[0] for p in iterable_props]:  # noqa: C412
            continue
        key = pascal_to_snake(key).replace(&#34;stack_&#34;, &#34;&#34;)
        setattr(self, key, value)
    if self.status in StackStatus.IN_PROGRESS:
        self._timer = Timer(
            self._auto_refresh_interval.total_seconds(), self.refresh
        )
        self._timer.start()</code></pre>
</details>
</dd>
<dt id="taskcat.Stack.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, *args, **kwargs):
    raise NotImplementedError(&#34;Stack updates not implemented&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="taskcat.Template"><code class="flex name class">
<span>class <span class="ident">Template</span></span>
<span>(</span><span>template_path, project_root='', url='', s3_key_prefix='')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Template:
    def __init__(
        self,
        template_path: Union[str, Path],
        project_root: Union[str, Path] = &#34;&#34;,
        url: str = &#34;&#34;,
        s3_key_prefix: str = &#34;&#34;,
    ):
        self.template_path: Path = Path(template_path).expanduser().resolve()
        self.template = cfnlint.decode.cfn_yaml.load(str(self.template_path))
        with open(template_path, &#34;r&#34;) as file_handle:
            self.raw_template = file_handle.read()
        project_root = (
            project_root if project_root else self.template_path.parent.parent
        )
        self.project_root = Path(project_root).expanduser().resolve()
        self.url = url
        self._s3_key_prefix = s3_key_prefix
        self.children: List[Template] = []
        self._find_children()

    def __str__(self):
        return str(self.template)

    def __repr__(self):
        return f&#34;&lt;Template {self.template_path} at {hex(id(self))}&gt;&#34;

    @property
    def s3_key(self):
        suffix = str(self.template_path.relative_to(self.project_root))
        return self._s3_key_prefix + suffix

    @property
    def linesplit(self):
        return self.raw_template.split(&#34;\n&#34;)

    def write(self):
        &#34;&#34;&#34;writes raw_template back to file, and reloads decoded template, useful if
        the template has been modified&#34;&#34;&#34;
        with open(str(self.template_path), &#34;w&#34;) as file_handle:
            file_handle.write(self.raw_template)
        self.template = cfnlint.decode.cfn_yaml.load(self.template_path)
        self._find_children()

    def _template_url_to_path(self, template_url):
        # TODO: this code assumes a specific url schema, should rather attempt to
        #  resolve values from params/defaults
        if isinstance(template_url, dict):
            if &#34;Fn::Sub&#34; in template_url.keys():
                if isinstance(template_url[&#34;Fn::Sub&#34;], str):
                    template_path = template_url[&#34;Fn::Sub&#34;].split(&#34;}&#34;)[-1]
                else:
                    template_path = template_url[&#34;Fn::Sub&#34;][0].split(&#34;}&#34;)[-1]
            elif &#34;Fn::Join&#34; in list(template_url.keys())[0]:
                template_path = template_url[&#34;Fn::Join&#34;][1][-1]
        elif isinstance(template_url, str):
            template_path = &#34;/&#34;.join(template_url.split(&#34;/&#34;)[-2:])
        template_path = self.project_root / template_path
        if template_path.is_file():
            return template_path
        LOG.error(
            &#34;Failed to discover path for %s, path %s does not exist&#34;,
            template_url,
            template_path,
        )
        return &#34;&#34;

    def _get_relative_url(self, path: str) -&gt; str:
        if not self.url:
            return &#34;&#34;
        suffix = str(self.template_path).replace(str(self.project_root), &#34;&#34;)
        suffix_length = len(suffix.lstrip(&#34;/&#34;).split(&#34;/&#34;))
        url_prefix = &#34;/&#34;.join(self.url.split(&#34;/&#34;)[0:-suffix_length])
        suffix = str(path).replace(str(self.project_root), &#34;&#34;)
        url = url_prefix + suffix
        return url

    def url_prefix(self) -&gt; str:
        if not self.url:
            return &#34;&#34;
        suffix = str(self.template_path).replace(str(self.project_root), &#34;&#34;)
        suffix_length = len(suffix.lstrip(&#34;/&#34;).split(&#34;/&#34;))
        url_prefix = &#34;/&#34;.join(self.url.split(&#34;/&#34;)[0:-suffix_length])
        return url_prefix

    def _find_children(self) -&gt; None:  # noqa: C901
        children = set()
        if &#34;Resources&#34; not in self.template:
            raise TaskCatException(
                f&#34;did not receive a valid template: {self.template_path} does not &#34;
                f&#34;have a Resources section&#34;
            )
        for resource in self.template[&#34;Resources&#34;].keys():
            resource = self.template[&#34;Resources&#34;][resource]
            if resource[&#34;Type&#34;] == &#34;AWS::CloudFormation::Stack&#34;:
                child_name = self._template_url_to_path(
                    resource[&#34;Properties&#34;][&#34;TemplateURL&#34;]
                )
                if child_name:
                    children.add(child_name)
        for child in children:
            child_template_instance = None
            for descendent in self.descendents:
                if str(descendent.template_path) == str(child):
                    child_template_instance = descendent
            if not child_template_instance:
                try:
                    child_template_instance = Template(
                        child,
                        self.project_root,
                        self._get_relative_url(child),
                        self._s3_key_prefix,
                    )
                except Exception:  # pylint: disable=broad-except
                    LOG.debug(&#34;Traceback:&#34;, exc_info=True)
                    LOG.error(f&#34;Failed to add child template {child}&#34;)
            if isinstance(child_template_instance, Template):
                self.children.append(child_template_instance)

    @property
    def descendents(self) -&gt; List[&#34;Template&#34;]:
        desc_map = {}

        def recurse(template):
            for child in template.children:
                desc_map[str(child.template_path)] = child
                recurse(child)

        recurse(self)

        return list(desc_map.values())

    def parameters(
        self
    ) -&gt; Dict[str, Union[None, str, int, bool, List[Union[int, str]]]]:
        parameters = {}
        for param_key, param in self.template.get(&#34;Parameters&#34;, {}).items():
            parameters[param_key] = param.get(&#34;Default&#34;)
        return parameters</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="taskcat.Template.descendents"><code class="name">var <span class="ident">descendents</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def descendents(self) -&gt; List[&#34;Template&#34;]:
    desc_map = {}

    def recurse(template):
        for child in template.children:
            desc_map[str(child.template_path)] = child
            recurse(child)

    recurse(self)

    return list(desc_map.values())</code></pre>
</details>
</dd>
<dt id="taskcat.Template.linesplit"><code class="name">var <span class="ident">linesplit</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def linesplit(self):
    return self.raw_template.split(&#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="taskcat.Template.s3_key"><code class="name">var <span class="ident">s3_key</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def s3_key(self):
    suffix = str(self.template_path.relative_to(self.project_root))
    return self._s3_key_prefix + suffix</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="taskcat.Template.parameters"><code class="name flex">
<span>def <span class="ident">parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parameters(
    self
) -&gt; Dict[str, Union[None, str, int, bool, List[Union[int, str]]]]:
    parameters = {}
    for param_key, param in self.template.get(&#34;Parameters&#34;, {}).items():
        parameters[param_key] = param.get(&#34;Default&#34;)
    return parameters</code></pre>
</details>
</dd>
<dt id="taskcat.Template.url_prefix"><code class="name flex">
<span>def <span class="ident">url_prefix</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def url_prefix(self) -&gt; str:
    if not self.url:
        return &#34;&#34;
    suffix = str(self.template_path).replace(str(self.project_root), &#34;&#34;)
    suffix_length = len(suffix.lstrip(&#34;/&#34;).split(&#34;/&#34;))
    url_prefix = &#34;/&#34;.join(self.url.split(&#34;/&#34;)[0:-suffix_length])
    return url_prefix</code></pre>
</details>
</dd>
<dt id="taskcat.Template.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>writes raw_template back to file, and reloads decoded template, useful if
the template has been modified</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self):
    &#34;&#34;&#34;writes raw_template back to file, and reloads decoded template, useful if
    the template has been modified&#34;&#34;&#34;
    with open(str(self.template_path), &#34;w&#34;) as file_handle:
        file_handle.write(self.raw_template)
    self.template = cfnlint.decode.cfn_yaml.load(self.template_path)
    self._find_children()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="taskcat.exceptions" href="exceptions.html">taskcat.exceptions</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="taskcat.main" href="#taskcat.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="taskcat.Config" href="#taskcat.Config">Config</a></code></h4>
<ul class="">
<li><code><a title="taskcat.Config.create" href="#taskcat.Config.create">create</a></code></li>
<li><code><a title="taskcat.Config.get_buckets" href="#taskcat.Config.get_buckets">get_buckets</a></code></li>
<li><code><a title="taskcat.Config.get_params_from_templates" href="#taskcat.Config.get_params_from_templates">get_params_from_templates</a></code></li>
<li><code><a title="taskcat.Config.get_regions" href="#taskcat.Config.get_regions">get_regions</a></code></li>
<li><code><a title="taskcat.Config.get_rendered_parameters" href="#taskcat.Config.get_rendered_parameters">get_rendered_parameters</a></code></li>
<li><code><a title="taskcat.Config.get_templates" href="#taskcat.Config.get_templates">get_templates</a></code></li>
<li><code><a title="taskcat.Config.get_tests" href="#taskcat.Config.get_tests">get_tests</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="taskcat.Stack" href="#taskcat.Stack">Stack</a></code></h4>
<ul class="">
<li><code><a title="taskcat.Stack.REMOTE_TEMPLATE_PATH" href="#taskcat.Stack.REMOTE_TEMPLATE_PATH">REMOTE_TEMPLATE_PATH</a></code></li>
<li><code><a title="taskcat.Stack.children" href="#taskcat.Stack.children">children</a></code></li>
<li><code><a title="taskcat.Stack.create" href="#taskcat.Stack.create">create</a></code></li>
<li><code><a title="taskcat.Stack.delete" href="#taskcat.Stack.delete">delete</a></code></li>
<li><code><a title="taskcat.Stack.descendants" href="#taskcat.Stack.descendants">descendants</a></code></li>
<li><code><a title="taskcat.Stack.error_events" href="#taskcat.Stack.error_events">error_events</a></code></li>
<li><code><a title="taskcat.Stack.events" href="#taskcat.Stack.events">events</a></code></li>
<li><code><a title="taskcat.Stack.import_existing" href="#taskcat.Stack.import_existing">import_existing</a></code></li>
<li><code><a title="taskcat.Stack.refresh" href="#taskcat.Stack.refresh">refresh</a></code></li>
<li><code><a title="taskcat.Stack.resources" href="#taskcat.Stack.resources">resources</a></code></li>
<li><code><a title="taskcat.Stack.set_stack_properties" href="#taskcat.Stack.set_stack_properties">set_stack_properties</a></code></li>
<li><code><a title="taskcat.Stack.update" href="#taskcat.Stack.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="taskcat.Template" href="#taskcat.Template">Template</a></code></h4>
<ul class="two-column">
<li><code><a title="taskcat.Template.descendents" href="#taskcat.Template.descendents">descendents</a></code></li>
<li><code><a title="taskcat.Template.linesplit" href="#taskcat.Template.linesplit">linesplit</a></code></li>
<li><code><a title="taskcat.Template.parameters" href="#taskcat.Template.parameters">parameters</a></code></li>
<li><code><a title="taskcat.Template.s3_key" href="#taskcat.Template.s3_key">s3_key</a></code></li>
<li><code><a title="taskcat.Template.url_prefix" href="#taskcat.Template.url_prefix">url_prefix</a></code></li>
<li><code><a title="taskcat.Template.write" href="#taskcat.Template.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>